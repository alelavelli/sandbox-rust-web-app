use amqprs::{
    callbacks::{DefaultChannelCallback, DefaultConnectionCallback},
    channel::{BasicPublishArguments, QueueBindArguments, QueueDeclareArguments},
    connection::{Connection, OpenConnectionArguments},
    BasicProperties,
};
use tracing::info;

async fn rabbitmq_example() {
    // open a connection to RabbitMQ server
    let connection = Connection::open(&OpenConnectionArguments::default())
    .await
    .unwrap();
    connection
        .register_callback(DefaultConnectionCallback)
        .await
        .unwrap();
    info!("Created connection");
    // open a channel on the connection
    let channel = connection.open_channel(None).await.unwrap();
    channel
        .register_callback(DefaultChannelCallback)
        .await
        .unwrap();
    info!("Created channel");
    // declare a queue
    let (queue_name, _, _) = channel
        .queue_declare(QueueDeclareArguments::new("manager"))
        .await
        .unwrap()
        .unwrap();
    info!("Created queue");
    /*let routing_key = "amqprs.example";
    let exchange_name = "amq.topic";*/
    let routing_key = "manager";
    let exchange_name = "amq.topic";
    channel
        .queue_bind(QueueBindArguments::new(
            &queue_name,
            exchange_name,
            routing_key,
        ))
        .await
        .unwrap();
    info!("Created bind");
    // publish message
    let content = String::from(
        r#"
        {
            "publisher": "example",
            "group_id": "new_queue",
            "payload": {"queue_name": "rust-queue"}
        }
    "#,
    )
    .into_bytes();

    // create arguments for basic_publish
    let args = BasicPublishArguments::new(exchange_name, routing_key);

    channel
        .basic_publish(BasicProperties::default(), content, args)
        .await
        .unwrap();
    info!("Created message sent");
    connection.close().await.unwrap();
}